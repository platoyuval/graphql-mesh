---
description:
  Publish events with GraphQL Subscriptions in your unified schema using GraphQL Mesh.
---

import { Callout, PackageCmd } from '@theguild/components'

# Publish events with GraphQL Subscriptions

GraphQL Mesh can consume Webhooks as GraphQL Subscriptions in the unified schema by using the
built-in PubSub implementation

## A basic hello world approach to publishing GraphQL events
> This approach does not use Webhooks

### Defining the subscriptions
Modify the `.meshrc.yaml` file and create (or use an existing) a `additionalTypeDefs` section, then append a definition of the subscription type definitions

```yaml filename=".meshrc.yaml"
additionalTypeDefs: |
  # If you don't have Subscription type defined anywhere
  # You have to extend subscription definition
  extend schema {
    subscription: Subscription
  }

  # This type can also come from the underlying service
  type AnotherThingHappenedEvent {
    # TODO: Define your event fields as needed
    reason: String
    counter: Int
  }

  type Subscription {
    # A simple subscription example using a integer scalar for event data
    somethingHappened: Int @resolveTo(
      pubsubTopic: "SomethingHappenedTopic"
    )

    # A more advanced subscription example using an event type
    anotherThingHappened: AnotherThingHappenedEvent @resolveTo(
      pubsubTopic: "AnotherThingHappenedTopic"
    )
  }
```

For event data types, existing types from unified schema can be used or new types can be defined on the mesh service as shown above.
The `@resolveTo` directive will cause a async iterator resolver to be auto generated by GraphQL Mesh. The subscription resolver is needed when the GraphQL subscription is initiated by the client.

`pubsubTopic` can have any name of a topic.

### Publishing an event by topic

One of the useful paradigms is for the mesh to listen to events coming from internal queuing systems, such as RabbitMQ, and then re-publishing the event as an external GraphQL subscription event.

A consumer to the queuing system is created on the mesh service main logic, it listens to incoming events.
When an event arrives the queue listener publishes a GraphQL event with the following logic:

```typescript
  import { getBuiltMesh } from './.mesh'

...

  const yourQueueListener = (event: EventType) => {
    // event is the incoming queuing event (e.g. RabbitMQ message)

    // Gets the GraphQL Mesh instance
    const mesh = await getBuiltMesh()
    // The Graphql Mesh has internal pubsub implementation
    mesh.pubsub.publish('SomethingHappenedTopic', event.data)
  }


  ...

  const initializeYourApplication = () => {
    // Pseudo code - change to actual framework, such as RabbitMQ
    subscribeToInternalQueue('ATopicName', yourQueueListener)
  }
```


